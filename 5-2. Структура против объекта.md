# Структура против объекта 

Структура практические ничем не отличается от класса. Не верите? Сейчас докажу.

В языке Си были только структуры. В С++ появились классы.

В чем отличие структуры от класса?
Глобально - **НИ В ЧЕМ**. Единственное отличие:
* В структуре все члены доступны для использования по умолчанию, пока не заявлено обратное.
* В классе все члены недоступны для использования никому вне этого класса, пока не заявлено обратное.

```c++
include <iostream>
using namespace std;

namespace StructVsClass
{
    struct Plant
    {
        int age; 
    private:
        int rootCount;
    };


    class Table
    {
        int humidity;	
    public:	
        int legCount; 
    };


    struct Animal
    {
        char* name;

        Animal()
        {
            cout << "Я родился!" << endl;
            chipId = 4;

            name = new char[8]{ 'C', 'h', 'i', 'm', 'a', 'e', 'r', 'a' };
        }

        ~Animal()
        {
            cout << ":'(" << endl;
        }

           private: 
        int chipId; 
    };

    struct Dog : Animal
    {
        Dog()
        {
            cout << "Щеночек!" << endl;
            cout << "Дайте щеночку имя: ";
            char* buff = new char[255];
            cin >> buff;

            name = new char[strlen(buff)];
            strcpy(name, buff);

            delete[] buff;

        }

        void Bark()
        {
            cout << "Гав!" << endl;
        }
    };

    void main()
    {
        Dog dog;
        dog.Bark();

        cout << dog.name << endl;
      
    }
}
```

Сначала рассмотрим пример структур.

По умолчанию в структуре все члены доступны извне структуры, т.е. они **ПУБЛИЧНЫЕ**.

```c++
    struct Plant
    {
        int age; // публичное поле
    private:// можно создать ПРИВАТНЫЕ члены структуры
            // такие члены будут доступны только внутри самой структуры

        int rootCount;	// вряд ли кому-то кроме самой структуры "растение"
                        // интересно знать кол-во корней у растения 
    };
```

Ситуация с классами обратная:

По умолчанию в классе все члены недоступны извне класса, т.е. они **ПРИВАТНЫЕ**.
```c++
    class Table
    {

        int humidity;	// параметр влажности будет скрыт для всех,
                        // кроме самого класса
    public:	// если нужно дать доступ до какого-то члена класса,
            // то их помечают ПУБЛИЧНЫМИ

        int legCount; // кол-во ножек у стола будет доступно всем
    };
```
Многие ошибочно полагают, что  отличие структуры от класса в том, что в классе есть методы, а в структуре - нет или что в структуры не поддерживают наследование. Но это ошибка.

 У структуры может быть **конструктор**

```c++
        Animal()
        {
            cout << "Я родился!" << endl;
            chipId = 4;

            name = new char[8]{ 'C', 'h', 'i', 'm', 'a', 'e', 'r', 'a' };
        }
```

**Деструктор** тоже может быть
```c++
        ~Animal()
        {
            cout << ":'(" << endl;
        }
```
**Модификаторы** доступа тоже могут быть разными
```c++
    private: // все поля объявленные ниже будут недоступны всем, кроме самого класса
        int chipId; // номер чипа у животного
```

Наследование? Легко!
```c++
    struct Dog : Animal
    {
        Dog()
        {
            cout << "Щеночек!" << endl;
            cout << "Дайте щеночку имя: ";
            char* buff = new char[255];
            cin >> buff;

            name = new char[strlen(buff)];
            strcpy(name, buff);

            delete[] buff;

        }
```

`chipId = 12;` - эта строчка вызывает ошибку,  потому что поле `chipId` недоступно для использования  из-за модификатора доступа `private` в родительской структуре `Animal`
      
```c++
    void main()
    {
        Dog dog;
        dog.Bark();

        cout << dog.name << endl;
    }
```
`cout << dog.chipId << endl;` - эта строчка вызывает ошибку, потому что поле `chipId` недоступно для использования  из-за модификатора доступа `private` в родительской структуре `Animal`


**Итог:**
* Классы - это следующая ступень развития структур, чтобы следовать всем требованиям ООП. На данный момент структуры существуют в том числе для обеспечения обратной совместимости с языком Си.

* Среди разработчиков принято следующее соглашение:
1. Если для хранения информации требуется придерживаться принципов ООП (инкапсуляции, наследования и т.д.), то используются классы.
2. Если же требуется лишь хранение информации, причем соблюдение инкапсуляции необязательно, то используются структуры.

* Но т.к. если программа пишется с использование объектно-ориентированного подхода, то чаще требуется полное соблюдение приципов ООП и структуры практически не используются. Поэтому зачастую структуры считаются просто устаревшим этапом развития классов.

**NB!**
* У структур могут быть методы!
* У структуры может быть конструктор и деструктор!
* Структуры можно наследовать!
