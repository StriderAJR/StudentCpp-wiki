# Перегрузка операторов

 
 Понятие оператора рассматривалось еще давно, в самых первых разделах данного вики.
 Вкратце, оператор - это некая команда, обозначаемая какими-то спецсимволами.
 
 Например, есть оператор `+`, `-`,` *`,` /`, `>>`, `<<`, `=`, `==`, `+=`, `!`, `&`, `&&`, `|`, `||` и т.д. Это все операторы.
 
> **Оператор** - это в первую очередь "действие", он что-то делает. А все куски кода, которые что-то делают называются функциями. Функции, привязанные к классам, принято называть методами.
  
На самом деле все именно так: оператор - это ф-ция с особым зарезервированным именем.
Имя это выглядит так: `operator+`, `operator-`, `operator*`, `operator>>`, `operator&&` и т.д.

Поэтому когда вы пытаетесь сложить два числа типа `int`
```c++    
     a + b
```

то на самом деле компилятором это преобразуется в вызов:
```c++ 
operator+(a, b);
 ```
где ф-ция имеет следующий прототип:
```c++ 
int operator(int, int);
```

т.е. принимает 2 параметра типа данных `int` и возвращает результат типа данных `int`.
Так вот. В компилятор встроено определенное кол-во операторов и их перегрузок для разных типов данных.
 ```c++    
    int a1, a2, a3;
    double b1, b2, b3;
     
    a3 = a1 + a2;
    b3 = b1 + b2;
 ```  
 что компилятором преобразуется в:
 ```c++   
    a3 = operator+(a1, a2);
    b3 = operator+(b1, b2);
 ```
 на самом деле в этих строчках вызываются 2 разные ф-ции `operator+`. Их сигнатуры выглядят по-разному.
```c++     
    int operator+(int, int);
    double operator+(double, double);
```     
И таких перегрузок достаточно много. Для всех простых типов данных. Это встроено в компилятор языка С++.
А теперь встает вопрос о пользовательских типах данных, т.е. классах. Очень часто нам хотелось бы
иметь возможность совершать некоторые операции над целыми объектами. Складывать, вычитать, перемножать,
выполнять индексацию (как с массивами) и т.п.

Возьмем тему геометрия. У нас есть несколько сущностей: 
- точка, которая характеризуется 2-мя координатами
- отрезок, который состоит из двух точек

Сумма двух точек даст нам отрезок. Но разница двух точек даст нам точку, координаты которой  являются дельтой координат первой и второй точки.
```c++ 

#include <iostream>
using namespace std;

namespace OperatorOverloading
{
   class PointDummy
   {
      int x, y;
   public:
      PointDummy() : x(0), y(0) {}
      PointDummy(int x, int y) : x(x), y(y){}

      int getX() const { return x; }
      int getY() const { return y; }
      void setX(int x) { this->x = x; }
      void setY(int y) { this->y = y; }
   };

   class LineDummy
   {
      PointDummy p1, p2;
   public:
      LineDummy(const PointDummy& p1, const PointDummy& p2)
      {
         this->p1 = PointDummy(p1.getX(), p1.getY());
         this->p2 = PointDummy(p2.getX(), p2.getY());
      }
   };


   LineDummy& operator+(const PointDummy& p1, const PointDummy& p2)
   {
    
      return *(new LineDummy(p1, p2));
   }

   PointDummy& operator-(const PointDummy& p1, const PointDummy& p2)
   {
      return *(new PointDummy(p1.getX()-p2.getX(), p1.getY()-p2.getY()));
   }
 ```



Немножко пояснений, прежде чем вернемся к теме перегрузки операторов.

`Dummy` - в конце классов просто обозначение, что это временный демонстрационный класс,
немного неправильный с некоторых точек зрения и в дальнейшем будет переписан, и чтобы
не было конфликта имен, он назван немного по-другому.
 
А теперь из интересностей.

1. 
```c++
 LineDummy(const PointDummy& p1, const PointDummy& p2);
```
ни у кого уже не должно быть вопросов, почему тут стоит тип данных ссылка и модификатор `const`.
Если у кого-то вопросы все-таки возникли, то идет в раздел "Передача параметров по ссылке и по значению".

2. 
```c++
    PointDummy p1, p2;
```
опять же всем уже должно быть понятно, но все-таки еще раз поясню: когда поля создаются таким образом,
то при создании объекта `LineDummy`, сразу же в памяти создаются 2 объекта `PointDummy`.
Из-за того, что `PointDummy` имеет конструктор 
 ```c++
    PointDummy(int x, int y);
```
конструктор по умолчанию (который без параметров), автоматически создан не будет. Но тут 
```c++
    PointDummy p1, p2;
```
должен по идее вызываться именно конструктор по умолчанию, без параметров. Поэтому если мы не создали бы
конструктор
```c++
    PointDummy();
```
сами, у нас была бы ошибка `"no default constructor exists for class PointDummy"`. 
Так что пришлось создать и в нем координаты просто занулить. Поэтому на самом деле если задуматься, вот это все в сумме
```c++ 
     PointDummy p1, p2;
     LineDummy(const PointDummy& p1, const PointDummy& p2)
     {
        this->p1 = PointDummy(p1.getX(), p1.getY());
        this->p2 = PointDummy(p2.getX(), p2.getY());
     }
```    
неэффективно. Мы сначала создали 2 пустые координаты с нулевыми значения, а потом все равно в нормальном конструкторе
переинициализировали. Конечно, это только если нам не придется создавать много нулевых точек по умолчанию 
и где-то пользоваться ими. Тогда конструктор по умолчанию у `PointDummy` имеет смысл.

В данной же ситуации, когда точка по умолчанию нам не сдалась, можно поля `p1` и `p2` сделать указателями, чтобы
объекты сразу же не создавались. Но это так, пища для размышлений.
 
3.
Вот эта штука
```c++
    this->p1 = PointDummy(p1.getX(), p1.getY());
 ```
 а конкретно вызовы 
```c++ 
p1.getX()
```
 и 
```c++ 
p1.getY()
```
     
будут работать только если методы `getX` и `getY` помечены как константные.
```c++
    PointDummy getFirstPoint() const { return p1; }
```   
Если модификатора `const` не будет у этих методов, то 
```c++
     PointDummy(p1.getX(), p1.getY());
```    
будет подчеркивать `p1` и говорить, что 

`"the object has type qualifiers that are not compatible with the member function"`.
 
Поясню, потому что новичку это может быть не очевидно. Параметры `p1` и `p2` в конструкторе
```c++
    LineDummy(const PointDummy& p1, const PointDummy& p2)
 ```  
помечены как константные, т.е. они ни в коем случае не должны изменить в процессе работы метода. А внутри метода мы
вызываем методы `getX` и `getY`. А вдруг внутри этих методов точки как-то изменяются? А такого допустить никак нельзя.
    
Но вот если сами методы `getX` и `getY` будут иметь модификатор `const`, который гарантирует, что внутри этих методов
поля объекта никак не меняются - вот это другое дело. Это гарант, что при вызове этих методов содержимое объекта
не изменится.
     
Таким образом, если вы делаете параметры в методе константными, то можно пользоваться только константными методами
этих классов. Или объект может измениться где-то в иерархии вызовов методов.
    
4.
Почему здесь возврат значения по ссылке, а не по значению:
```c++     
     PointDummy getFirstPoint() const { return p1; }
     PointDummy getSecondPoint() const { return p2; }
```   
Можно было, конечно, сделать и ссылку. Если бы мы возвращали ссылку, то подразумевали, что хотим иметь возможность
изменять точку у отрезка. Если это действительно то, чего мы хотим, и это не противоречит безопасности данных в 
конкретной программе, то можно возвращать и ссылку.
    
Если же мы не хотим давать пользователю возможность через геттер давать возможность модификации поля класса, то
нужно использовать возврат значения по значению, чтобы отдать пользователю для ознакомления копию поля класса.
     
Поэтому тут каждый разработчик сам смотрит, какая логика ему нужна в программе.


   
А теперь возвращаемся к перегрузке операторов. Нам нужно иметь возможность складывать и вычитать две точки.

Сложение двух точек -> отрезок

Вычитание двух точен -> точка





 ```c++
  LineDummy& operator+(const PointDummy& p1, const PointDummy& p2)
   {
      return *(new LineDummy(p1, p2));
   }
 ```

Мне не хочется, чтобы объект создавался у меня в памяти дважды, я хочу создать объект один раз
и вернуть на него ссылку. Но сделать
 ```c++
       return LineDummy(p1, p2);
 ```
нельзя. Созданная статичная переменная будет локальной. Она уничтожится как только завершится ф-ция.
И результат выполнения функции будет ссылка, которая привязана к несуществующей ячейке в памяти.

Если тип возвращаемого значения ф-ции изменить с ссылки просто на `LineDummy` этой проблемы не будет,
потому что создастся копия, но зато объект будет создаваться дважды. Чтобы избежать и того, и другого
просто возьмем управление памятью на себя.
 ```c++
       LineDummy* newLine = new LineDummy(p1, p2);
       return *newLine;
 ```
или еще короче можно записать так:
 ```c++
 return *(new LineDummy(p1, p2));
 ```




Круто? Круто. Теперь мы можем писать что-нибудь типа:
 ```c++
     PointDummy p1(5, 5);
     PointDummy p2(1, 6);
     LineDummy line1 = p1 + p2;
     PointDummy p3 = p2 - p1;
 ```
 
Последние 2 строчки будут преобразовываться вот в такие:
 ```c++
    LineDummy line1 = operator+(p1, p2);
    PointDummy p3 = operator-(p2, p1);
 ```    
**Обратите внимание**, что при вызове оператора, выражение, которое стоит слева от оператора, 
будет первым параметром, а выражение справа от оператора - вторым параметром.

Поэтому у operator+ первый параметр `p1`, а второй - `p2`.
А у `operator-` первый - `p2`, второй - `p1`.



Поздравляю мы только что перезагрузили два оператор `+` и `-`.

А теперь давайте попробуем написать перегрузку умножения отрезка на какое-то число.
Допустим, мы хотим таким образом умножить координаты второй точки отрезка на это число.
Пусть результат нам не нужен - мы будем изменять сам отрезок.

Вроде бы, все просто. Но вот тут всплывет один неприятный момент. Начнем писать перегрузку.
 ```c++
    void operator*(LineDummy& line, int number)
    {
       line.p2.setX(line.p2.getX() * number);
       line.p2.setY(line.p2.getY() * number);
    }
 ```

И вот неприятность: у нас нет доступа до поля `p2` объекта `line`. Логично: оно приватное, а 
ф-ция оператора не принадлежит классу. Поэтому вполне ожидаемо, что нас ударили по рукам.

Ну и что делать? 

Ответом стала разработка механизма дружественных ф-ций.

>Дружественная функция класса - это функция, которой дали доступ до приватных и защищенных полей класса.Дружественная ф-ция должна быть объявлена в классе.

Т.е. нам достаточно в класс `LineDummy` добавить строчку
 ```c++

     friend void operator*(LineDummy& line, int number);
 ```

Это прототип ф-ции, который записан с модификатором `friend` - друг. Ага, скажи "друг" и тебе откроют. ;)

Чтобы не перемешивать код, продублируем класс `LineDummy` с дружественной ф-цией.


```c++ 

   class LineDummy2
   {
      PointDummy p1, p2;
   public:
      LineDummy2(const PointDummy& p1, const PointDummy& p2)
      {
         this->p1 = PointDummy(p1.getX(), p1.getY());
         this->p2 = PointDummy(p2.getX(), p2.getY());
      }

      friend void operator*(LineDummy2& line, int number);
   };

   void operator*(LineDummy2& line, int number)
   {
      line.p2.setX(line.p2.getX() * number);
      line.p2.setY(line.p2.getY() * number);
   }
```
Ну а теперь, собственно, наша дружественная ф-ция с перегрузкой оператора.
**Обратите внимание**, что класс используем уже `LineDummy2`.

 ```c++

   class LineDummy2
   {
      PointDummy p1, p2;
   public:
      LineDummy2(const PointDummy& p1, const PointDummy& p2)
      {
         this->p1 = PointDummy(p1.getX(), p1.getY());
         this->p2 = PointDummy(p2.getX(), p2.getY());
      }

      friend void operator*(LineDummy2& line, int number);
   };
 ```

Вот и славненько. Научились перегружать операторы даже если нам требуются приватные поля класса.


 ```c++

   void operator*(LineDummy2& line, int number)
   {
      line.p2.setX(line.p2.getX() * number);
      line.p2.setY(line.p2.getY() * number);
   }
 ```


 
**Обратите внимание**: дружественная ф-ция это не обязательно перегрузка оператора! Это может быть
любая ф-ция, в которой вам трубется получать доступ до приватных полей.

Однако, дружественные ф-ции на самом деле это костыль, такого механизма нет в истинных объектно-ориентированных языка.
Вы же помните, что С++ это псевдо объектно-ориентированных язык: взяли старый добрый Си, добавили в него возможности ООП
и стал С++ чем-то средним между структурным и объектно-ориентированным.

Поэтому на самом деле механизм дружественных ф-ций противоречит заветам ООП - не давать доступ до приватных полей
никому кроме самого класса. Поэтому я не рекомендую привыкать к этому способу работы с классом и перегрузке операторов в частности.

```c++ 
 

   // Point.h
   class Line;
   class Point
   {
      int x, y;
   public:
      Point();
      Point(int, int);

      int getX() const;
      int getY() const;
      void setX(int);
      void setY(int);

      Line& operator+(const Point&);
      Point& operator-(const Point&);
   };
   // end of Point.h

   // Line.h
   class Point;
   class Line
   {
      Point p1, p2;
   public:
      Line();
      Line(const Point&, const Point&);
      void operator*(int);

      Point getFirstPoint() const;
      Point getSecondPoint() const;
      void setFirstPoint(Point);
      void setSecondPoint(Point);
   };
   // end of Line.h

   // Point.cpp
   Point::Point() : x(0), y(0) {}
   Point::Point(int x, int y) : x(x), y(y) {}
   int Point::getX() const { return x; }
   int Point::getY() const { return y; }
   void Point::setX(int x) { this->x = x; }
   void Point::setY(int y) { this->y = y; }
   Line& Point::operator+(const Point& p2)
   {
      return *(new Line(*this, p2));
   }
   Point& Point::operator-(const Point& p2)
   {
      return *(new Point(this->getX() - p2.getX(), this->getY() - p2.getY()));
   }
   //end of Point.cpp

   // Line.cpp
   Line::Line() : p1(Point()), p2(Point()) {}
   Line::Line(const Point& p1, const Point& p2)
   {
      this->p1 = Point(p1.getX(), p1.getY());
      this->p2 = Point(p2.getX(), p2.getY());
   }
   void Line::operator*(int number)
   {
      this->p2.setX(this->p2.getX() * number);
      this->p2.setY(this->p2.getY() * number);
   }
   Point Line::getFirstPoint() const { return p1; }
   Point Line::getSecondPoint() const { return p2; }
   void Line::setFirstPoint(Point p1) { this->p1 = p1; }
   void Line::setSecondPoint(Point p2) { this->p2 = p2; }
   // end of Line.cpp

  
   ostream& operator<<(ostream& out, const Point& point)
   {
      out << "(" << point.getX() << "; " << point.getY() << ")";
      return out;
   }


   istream& operator>>(istream& in, Point& point)
   {
      int x, y;
      in >> x >> y;
      point.setX(x);
      point.setY(y);

      return in;
   }

   ostream& operator<<(ostream& out, const Line& line)
   {
      Point p1 = line.getFirstPoint();
      Point p2 = line.getSecondPoint();
      out << "p1" << p1 << " p2" << p2;
      
      return out;
   }

   istream& operator>>(istream& in, Line& line)
   {
      Point p1, p2;
      in >> p1 >> p2;
      line.setFirstPoint(p1);
      line.setSecondPoint(p2);

      return in;
   }

   void test()
   {
      Point p1, p2;
      Line line;

      cout << "Введите 2 координаты для p1: ";
      cin >> p1;
      cout << "Введите 2 координаты для p2: ";
      cin >> p2;
      cout << "А теперь введите введите 4 координаты для точек p1 и p2 отрезка: ";
      cin >> line;

      cout << endl << "Спасибо ^_^" << endl << 
         "Вы ввели: " << endl <<
         "p1 = " << p1 << endl << 
         "p2 = " << p2 << endl <<
         "line = " << line << endl;

      cout << endl << ":3" << endl;
   }

   int main()
   {
      PointDummy p1(5, 5);
      PointDummy p2(1, 6);
      LineDummy l = p1 + p2;
      PointDummy p3 = p2 - p1;

      Point p4(1, 1);
      Point p5(2, 2);
      Line line = p4 + p5;
      Point p6 = p5 - p4;
      line * 3;

      test();

      return 0;
   }
}
```

Перегрузить оператор на самом деле можно по-другому, более приемлемым способом, который используется и в истинных ОО языках.
Перегрузка оператора как метод класса. 

Ну а почему бы и нет? Если оператор это обычная ф-ция, а метод класса - это ф-ция, которая принадлежит классу.
Все что не запрещено - разрешено.

Ну и погнали тогда! Полностью перепишем наши классы.

 ```c++

     class Point;  
     class Line; 
 ```

Это "голые" объявления класса.
Пришлось так сделать, потому что у нас имеется перекрестное использование
классов внутри друг друга. А С++ читает код сверху вниз. Когда он дойдет до точки,
он еще не знает об отрезко. Если поместить отрезок выше, в нем есть упоминание точки.
Из этой ситуации можно выйти только если "пообещать" компилятору, что он найдет эти
классы где-то ниже в коде.



По-хорошему вообще нужно было разделить объявления и реализацию классов на
заголовочный файл **(*.h)** и файл реализации **(*.cpp)**. Но я ленивец, поэтому это уж как-нибудь
сами.

 ```c++

   // Point.h
   class Line;
   class Point
   {
      int x, y;
   public:
      Point();
      Point(int, int);

      int getX() const;
      int getY() const;
      void setX(int);
      void setY(int);

      Line& operator+(const Point&);
      Point& operator-(const Point&);
   };
   // end of Point.h
 ```


А вот сейчас о важном.

Внимательные могли заметить, что прототип ф-ции оператора изменился. 
Имена `LineDummy` и `PointDummy` заменены на `Line` и `Point` для удоства сравнения.
 
При перегрузке дружественной ф-цией было так:
 ```c++

   Line& operator+(const Point& p1, const Point& p2);
 ```

А при перегрузке методом класса стало так:
 ```c++
    Line& operator+(const Point& p2);
 ```

Если задуматься, то разница логична. При перегрузке дружественной ф-цией,
ф-ция ничего не знает об обоих требуемых операндах. А значит, для работы ей понадобится
явно задать 2 параметра: слева и справа от оператора.

Если же перегрузка идет методом класса, то один параметр у нас уже есть:
это сам тот объект, которому принадлежит вызываемый оператор.

Рассматорим развернутую запись
 ```c++
     p1 + p2;
 ```

для двух случаев: дружественная ф-ция и метод класса.

Дружественная ф-ция распишется как:
 ```c++

   operator+(p1, p2);
 ```
метод класса же:
 ```c++

    p1.operator(p2);
 ```

В случае с методом класса операнд, который стоит слева от оператора 
будет являться вызывающим объектом и указатель `this` внутри класса 
будет хранить адрес именно вызывающего объекта.

**<для_продвинутых>**
На самом деле, указатель `this`, который всегда доступен внутри методов класса - 
это передаваемый неявно (т.е. без вашего участия) параметр. Т.е. любой метод класса
на самом деле имеет на 1 параметр больше, чем вы записываете. Еще как один параметр
передается именно адрес вызываемого объекта.
 ```c++

    class Foo
    {
     public:
        void method1();
        void method2(int num);   
    };
 ```    
`method1` на самом деле имеет не ноль параметров, а один - `Foo* this`
`method2` на самом деле имеет не один параметр, а два - `int num` и `Foo* this`.

Именно поэтому указатель `this` доступен внутри методов класса - он неявно передается
при вызове метода.

**</для_продвинутых>**

Поэтому на просто нет необходимости перечислять для перегрузки оператора методом класса
оба параметра. Один параметр туда передастся и без наших действий.

Таким образом, когда мы перегружаем бинарный оператор, нам достаточно заявить всего один параметр,
а для унарного оператора нам вообще не нужны параметры, потому что действие будет совершаться над
самим объектом.
 ```c++

     class Foo
     {
       int num;
     public:
        void operator+(int anotherNum) 
       {
          num += anotherNum; 
       }
        void operator++()
        {
           num++;
        }
     };
 ```

Для сравнения та же логика организованная через дружественные ф-ции будет выглядеть так:
 ```c++
 
     class Foo
     {
        int num;
        friend void operator+(Foo&, int);
        friend void operator++(Foo& foo);
     };
     
     void operator+(Foo& foo, int number)
     {
        foo.num += number;
     }
    
     void operator++(Foo& foo)
     {
        foo.num++;
     }
 ```
 
 Вот и вся разница при перегрузке дружественной ф-цией и методом класса - только в кол-ве параметров.

 ```c++

   // Line.h
   class Point;
   class Line
   {
      Point p1, p2;
   public:
      Line();
      Line(const Point&, const Point&);
      void operator*(int);

      Point getFirstPoint() const;
      Point getSecondPoint() const;
      void setFirstPoint(Point);
      void setSecondPoint(Point);
   };
   // end of Line.h

   // Point.cpp
   Point::Point() : x(0), y(0) {}
   Point::Point(int x, int y) : x(x), y(y) {}
   int Point::getX() const { return x; }
   int Point::getY() const { return y; }
   void Point::setX(int x) { this->x = x; }
   void Point::setY(int y) { this->y = y; }
   Line& Point::operator+(const Point& p2)
   {
      return *(new Line(*this, p2));
   }
   Point& Point::operator-(const Point& p2)
   {
      return *(new Point(this->getX() - p2.getX(), this->getY() - p2.getY()));
   }
   //end of Point.cpp

   // Line.cpp
   Line::Line() : p1(Point()), p2(Point()) {}
   Line::Line(const Point& p1, const Point& p2)
   {
      this->p1 = Point(p1.getX(), p1.getY());
      this->p2 = Point(p2.getX(), p2.getY());
   }
   void Line::operator*(int number)
   {
      this->p2.setX(this->p2.getX() * number);
      this->p2.setY(this->p2.getY() * number);
   }
   Point Line::getFirstPoint() const { return p1; }
   Point Line::getSecondPoint() const { return p2; }
   void Line::setFirstPoint(Point p1) { this->p1 = p1; }
   void Line::setSecondPoint(Point p2) { this->p2 = p2; }
   // end of Line.cpp
 ```


Ну вот как-то так. Теперь мы снова можем делать вот такие вещи:
 ```c++

     Point p4(1, 1);
     Point p5(2, 2);
     Line line = p4 + p5;
     Point p6 = p5 - p4;
     line * 3;
 ```
     
Неплохо.

А теперь следующий вопрос. Допустим, я хочу иметь возможность записывать и читать объекты из потоков:
записывать/читать в/из файла, консоли, интернет соединения да и вообще любого потока.

И мы действительно можем перегрузить оператор `>>` и `<<` для работы с потоками и нашими классами.

И вот тут есть один нюанс. Как вы помните при перегрузке методом класса, вызывающий объект, которому
и должен принадлежать метод перегрузки стоит **СЛЕВА**. В записи
```c++

    cout << p1;
```

 Вызов оператора будет расписываться:
 ```c++

     cout.operator<<(p1);
 ```

Вызывающим объектом, у которого вызывается метод-оператор - это `cout`. Чтобы сделать перегрузку для
класса `Point` нам нужно идти в исходники потока `cout` и там добавлять перегрузку... Но у нас нет такого
доступа до исходников чужой библиотеки.

И вот тут из-за особенностей С++ без дружественных ф-ций не обойтись.

Перегрузка операторов `<<` и `>>` для потоков возможно **ТОЛЬКО** с помощью дружественных функций.

Такая перегрузка будет принимать 2 параметра: ссылка на поток и объект, который вы хотите писать/читать в потоке.

Параметр потока обязательно должен иметь тип данных ссылка. Иначе будет запускаться копирование (которое, например,
у потока консоли вообще заблокировано и вызовет ошибку) и писать вы в лудшем случае будете куда-то не туда,
но скорее всего у вас вообще будет ошибка.

 ```c++

   ostream& operator<<(ostream& out, const Point& point)
   {
      out << "(" << point.getX() << "; " << point.getY() << ")";
      return out;
   }
 ```
 

**Обратите внимание**:

 `ostream& operator<<(ostream& out, const Point point) `
 
Явно не указано, какой именно поток используется. `ostream` - это абстрактный `output stream` и не понятно
принадлежит ли он консоли, файлу или чему-то другому. Этим потоком может оказаться любой из потоков.
 Очень удобно.

А еще **обратите внимание**, что не пришлось объявлять оператор внутри класса как дружественную ф-цию,
потому что мы не используем напрямую приватные поля, а пользуемся предусмотренными геттерами и сеттерами.

При данной логике программы это не противоречит безопасности данных. Иначе да, нам пришлось бы объявить
эту перегрузку как дружественную ф-цию.
 ```c++

   istream& operator>>(istream& in, Point& point)
   {
      int x, y;
      in >> x >> y;
      point.setX(x);
      point.setY(y);

      return in;
   }

   ostream& operator<<(ostream& out, const Line& line)
   {
      Point p1 = line.getFirstPoint();
      Point p2 = line.getSecondPoint();
      out << "p1" << p1 << " p2" << p2;
      
      return out;
   }
 ```


**<для_продвинутых>**
На самом деле при перегрзуке операторов `<<` и `>>` не обязательно, чтобы был тип возаращаемого значения.
Вполне можно было бы обойтись и `void`
 ```c++

       void operator<<(ostream& out, const Point& point);
       void operator>>(istream& in, Point& point);
 ```

Но если хочется, чтобы работала цепочечная запись 
 ```c++

      out << "p1" << p1 << " p2" << p2;
 ```

то перегрузка оператора `<<` для точки должна была обязательно возвращать `ostream&`
 ```c++

        ostream& operator<<(ostream& out, const Point& point);
 ```
Иначе получится, что после первого вывода `p1`
```c++ 
 out << "p1" << p1;
```
нам вернется `void` и следующий оператор `<<` ни к чему не может быть применем.

![Alt  Texr](https://pp.userapi.com/c834404/v834404565/138bfe/x_QwM6ZOEME.jpg)
                                  
Если же наши перегрузки будут возвращать тот же поток, в который и писали, то все будет нормально.
        
То же самое действительно и для оператора `>>`.

**</для_продвинутых>**

 ```c++

   istream& operator>>(istream& in, Line& line)
   {
      Point p1, p2;
      in >> p1 >> p2;
      line.setFirstPoint(p1);
      line.setSecondPoint(p2);

      return in;
   }

   void test()
   {
      Point p1, p2;
      Line line;

      cout << "Введите 2 координаты для p1: ";
      cin >> p1;
      cout << "Введите 2 координаты для p2: ";
      cin >> p2;
      cout << "А теперь введите введите 4 координаты для точек p1 и p2 отрезка: ";
      cin >> line;

      cout << endl << "Спасибо ^_^" << endl << 
         "Вы ввели: " << endl <<
         "p1 = " << p1 << endl << 
         "p2 = " << p2 << endl <<
         "line = " << line << endl;

      cout << endl << ":3" << endl;
   }

   int main()
   {
      PointDummy p1(5, 5);
      PointDummy p2(1, 6);
      LineDummy l = p1 + p2;
      PointDummy p3 = p2 - p1;

      Point p4(1, 1);
      Point p5(2, 2);
      Line line = p4 + p5;
      Point p6 = p5 - p4;
      line * 3;

      test();

      return 0;
   }
}
```
