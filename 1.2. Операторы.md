> Оператор - некая фраза в языке программирования, определяющая законченный этап обработки данных одного или двух операндов.

* Операторы выражения
	* Приоритет операторов
* Приведение типов
* Условные операторы
	* Оператор `if`
	* Тернарный оператор
	* Оператор `switch`
* Операторы цикла
* Операторы перехода
* Ссылки на исходники

## Операторы выражения
Если упростить еще сильнее, то оператор - это какое-то действие, которое может иметь один или два параметра.

```c++
int a = 5;
```

`=` - это оператор. Оператор присваивания. Его операндами (параметрами) являются число `5` и переменная `a`. Этот оператор инициализирует переменную `a` числом `5` (в область памяти, помеченную именем `a`, записывается число `5`).

Операторы могут состоять не только из одного символа. Существуют такие операторы, как `if`, `switch`, `new`, `delete` и т.д. Это тоже операторы. Но обо всем в свое время.

### Оператор расширения (уточнения) видимости `::`
Это достаточно простой оператор, с которым мы уже работали, когда писали первую программу:
```c++
std::cout << "Hello, World!";
```
* Левый операнд оператора `::` - это верхний в иерархии объект, внутри которого что-то есть.
* Правый операнд оператора `::` - это нижний в иерархии объект, который мы специализируем

```

namespace std
|-- cout
|-- cin
|-- что-то-еще

```

Если сформулировать еще проще: оператор `::` говорит в какой "коробке" мы ищем нужную нам вещь. И запись `std::cout` расшифровывается как "внутри пространства `std` найди объект `cout`".

Все. Не больше и не меньше. Оператор `::` позволяет нам сказать точно, где находится тот или иной объект/функция.

### Арифметические операторы `+`, `-`, `*`, `/`, `%`
Это бинарные операторы, т.е. им нужно 2 операнда (параметра) для работы, левый и правый.
* `+` - сложение (внезапно!)
* `-` - вычитание (невероятно!)
* `*` - умножение (кто бы мог подумать!)
* `/` - целочисленное деление, дробная часть результата будет отброшена, даже если она должна была бы быть
* `%` - остаток от деления

```c++
int a = 10;
cout << a + 1; // 11
cout << a - 1; // 9
cout << a * 2; // 20
cout << a / 3; // 3
cout << a % 3; // 1
```

### Постфиксный и префиксный инкремент `++` и декремент `--`
Операторы инкремента и декремента содержат в себе оператор присваивания. Выражения
```c++
a++;
b--;
```
полностью эквивалентно записи
```c++
a = a + 1;
b = b - 1;
```
Но инкремент и декремент еще могут быть постфиксные и инфиксные. Постфиксный - оператор стоит **после** операнда. Инфиксиный - оператор стоит **до** операнда. Разницу между постфиксном и инфиксном проще показать на примере.

```c++
int a = 0;
int b = 0;
cout << a++ << endl; // выведется... 0
cout << ++b << endl; // выведется... 1
```
Сложно сказать, что вам покажется более странным, что в первом случае вывелся 0, или что во втором случае вывелось 1, или что вообще есть разница в результате для этих двух строк.

Разница между инфиксом и постфиксом в том, что произойдет раньше: инкремент/декремент или вы получите значение переменной. Давайте я просто распишу верхний алгоритм на составляющие:

```c++
int a = 0;
int b = 0;

cout << a << endl;
a = a + 1;

b = b + 1;
cout << b << endl;

```
Вот теперь отлично видно, что в случае с постфиксом, мы сначала используем операнд в своем выражении и только затем происходит инкремент.

В случае с инфиксом сначала происходит инкремент и только затем операнд участвует в выражении. 

Эта разница бывает критичной в алгоритмах, поэтому стоит об этом помнить.

### Логические операторы `==`, `!=`, `>`, `<`, `>=`, `<=`
Логические операторы возвращают результатом своей работы логический тип данных `bool`. 
* `==` - проверка на равенство
* `!=` - проверка на неравенство
Остальные операторы, кажется, даже пояснять нужды нет.

### Логические и побитовые операторы `&&` и `&`, `||` и `|`, `!` и `~`, `^`
* `&` - конъюнкция 
* `|` - дизъюнкция
* `!` и `~` - отрицание
* `^` - исключающая дизъюнкция

Есть такие "веселые" парные операторы, которые вечно начинающие забывают разделять в своей голове на 2 разные подгруппы: логические и побитовые. У логической группы результатом будет тип `bool` - истина или ложь, побитовая же группа операторов в качестве результата выдает **число**.

* Логическая группа это операторы `&&`, `||`, `!`
```c++
int a = 10;
int b = 0;
bool c = true;

cout << (a && b) << endl; // 0
cout << (a && c) << endl; // 1
cout << (b && c) << endl; // 0

// Выражение пришлось записать в круглых скобках из-за приоритета операторов
// У оператора && приоритет ниже, чем у <<

```
Надеюсь, вы помните, почему вывод получился `0` и `1` - потому что в С++ логический тип данных все равно числа. Автоматически красивые слова `true` и `false` вам никто не выведет, это прерогатива уже более высокоуровневых языков типа С#.

* Побитовая группа это операторы `&`, `|`, `~`
Особенность побитовых арифметических операторов, что они работают с двоичным представлением числа и причем с каждым отдельным битом, а не со всем числом в целом. Результат получается целочисленное число.
```c++
int a = 3;
int b = 4;
bool c = 1;

cout << (a & b) << endl;
cout << (a | b) << endl;
cout << (a ^ b) << endl;
cout << (~c) << endl;
```
Если записать побитого каждое число, то
```
a = 0011
b = 0100
c = 0001

0011 & 0100 = 0000 = 0
0011 | 0100 = 0111 = 7
0011 ^ 0100 = 0111 = 7
```

Так что не нужно путать пары: `&` и `&&`, `|` и `||` - это разные операторы с разным результатом и даже разным типом данных результата.

### Побитовый сдвиг `>>`, `<<`
Это тоже побитовые операторы. Они сдвигают число на нужное кол-во разрядов вправо или влево.
```c++
int a = 1;
cout << (a << 2) << endl; // 4
```

```
0001 << 2 = 0100 = 4
```
И помните, что `cout << "Hello"` и `a << 2` - это один и тот же оператор побитого сдвига. Но в дальнейшем мы изучим, что поведение оператора можно менять для разных типов данных. Поэтому оператор `<<` для потока ввода/вывода не сдвигает что-то там влево, а записывает или читает из потока данные. Но оператор и там, и там - это оператор побитого сдвига, но его поведение изменили именно для потока. Это называется "перегрузить оператор" и будет изучаться в дальнейшем.

### Комбинированные операторы с присваиванием
В С++ есть комбинированные операторы, которые образовались как краткая запись самого оператора вместе с присваиванием.
```c++
a = a+5;
```
можно записать также как
```c++
a += 5;
```
Эти строчки будут полностью эквивалентны.

И таких "сокращенных" операторов очень много:
```c++
a -= 1; // a = a-1;
a *= 2; // a = a*2;
a /= 3; // a = a / 3;
a %= 4; // надеюсь, дальше мне уже не нужно расписывать?
a <<= 5;
a >>= 6;
a &= 7;
a ^= 8;
a |= 9;
```

## Оператор `sizeof`
## Оператор `,`
## Приведение типов
TODO
## Приоритет операторов
```c++
int a = 5;
int b = 7;
int c = a+b;
```

В последней строке применяется сразу 2 оператора. Сначала выполняется оператор `+`, а затем оператор `=`. Почему именно в таком порядке? Потому что в любом языке программирования, также как в математических выражениях, у операторов есть приоритет.

Например, оператор `+` имеет больший приоритет чем оператор `=`. Именно поэтому сначала вычислится сумма двух переменных: `a` и `b` и только затем результат присвоится переменной `c`.

```c++
int a = 5;
int b = 7;
int c = a+b*a; // c будет равно 40, а не 60
```

Полный перечень операторов с их приоритетами можно найти в любом справочнике или тематической сайте, например, [CppReference - Приоритет операций](https://ru.cppreference.com/w/cpp/language/operator_precedence)
## Условные операторы
### Оператор if
TODO
### Тернарный оператор
TODO
### Оператор switch
TODO
## Операторы цикла
TODO
## Операторы перехода
TODO

## Ссылки на исходники
* [todo](https://github.com/StriderAJR/StudentCpp/blob/master/source/Basics_03.1_Cast.h)
* [todo](https://github.com/StriderAJR/StudentCpp/blob/master/source/Basics_03.2_Operators.h)
* [todo](https://github.com/StriderAJR/StudentCpp/blob/master/source/Basics_03.3_ConditionOperator.h)
* [4_Cycles](https://github.com/StriderAJR/StudentCpp/blob/master/source/Basics_03.4_Cycles.h)
