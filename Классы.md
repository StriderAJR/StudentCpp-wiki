* [**Класс и объект**](https://github.com/Solomonov98/StudentCpp-wiki/blob/master/%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%9A%D0%BB%D0%B0%D1%81%D1%81-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82)
* [**Инкапсуляция**](https://github.com/Solomonov98/StudentCpp-wiki/blob/master/%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)
* [**Жизненный цикл объекта, конструктор, деструктор**](https://github.com/Solomonov98/StudentCpp-wiki/blob/master/%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D1%86%D0%B8%D0%BA%D0%BB-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80)
* [**Конструктор копирования**](https://github.com/Solomonov98/StudentCpp-wiki/blob/master/%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

# Класс и объект

> **Класс** - это пользовательский тип данных.
Класс не хранит никаких данных, это лишь общее описание того, какие данные и как будут храниться в памяти. Еще класс называют абстракицей, чем-то общим, универсальным, описательным.
    
 **Класс** состоит из:
*  **Полей** - переменных для хранения данных.
*   **Методов** - функций, которые может выполнять экземпляр класс.
   
   
>    **Объект** - переменная типа данных класс. Объект хранит какие-то конкретные данные. Еще объект называют конкретным воплощение (сущностью) класса.

  Создадим тип данных "Человек" - `Human`
  ```c++ 
#include <iostream>
#include <ctime>

using namespace std;

namespace Classes
{
class Human
	{
        
      unsigned long long passportNumber;
       
    public:
        int height; // Рост
        int weight; // Вес
        char* name; // Имя

        void setPassport(int height, int weight, const char* n)
        {
            
            this->height = height;
            this->weight = weight;
            name = new char[strlen(n)];
            strcpy(name, n);

            int r = rand();
            passportNumber = 1111111111 + (r * 9999999999) / RAND_MAX;
        }

        unsigned long long getPassportNumber()
        {
            return passportNumber;
        }
	};

    void main()
    {
        
        srand(time(nullptr)); 

        Human jack; 
        Human alex; 
                
        jack.setPassport(170, 80, "Jack Smith");
        alex.setPassport(170, 80, "Alex Ranger");

        cout << "Jack's passport: " << jack.getPassportNumber() << endl;
        cout << "Alex's passport: " << alex.getPassportNumber() << endl;
     
    }

} 
```


По умолчанию все элементы класса скрыты от посторонних глаз.

Чтобы сделать "внутренности" класса доступными для работы за его пределами нужно использовать "модификатор доступа"  `public` , таким образом мы говорим,  все что написано ниже этого слова - публичное, доступно всем для обозрения и использования.


```c++ 
       public:
        int height; // Рост
        int weight; // Вес
        char* name; // Имя
```

Обратите внимание, что параметры `height` и `weight` имеют такое же имя как поля класса.
Кстати, раз **класс** - это коробка с переменными и методами, то сам класс имеет доступ до всех своих "внутренностей" ВСЕГДА.

```c++

        this->height = height;
        this->weight = weight;
        name = new char[strlen(n)];
        strcpy(name, n);
```

При получении паспорта случайным образом генерируется его номер. Номер паспорта состоит из 4 цифр серии 1111 - 99999 и 6 цифр номера 111111 - 999999. Значит, нам нужно минимальное число 1111111111 и максимально 9999999999. Только `rand()` умеет генерировать строго определенный диапазон чисел. Значит, поможем ему попасть в нужный нам диапазон.

```c++
        int r = rand();
        passportNumber = 1111111111 + (r * 9999999999) / RAND_MAX;
```


Сначала проинициализируем генератор псведо-случайных чисел. Чтобы при каждом запуске генератор не выдавал одни и те же "случайные" значени, произведем скорпим генератору текущее время системы.
`time` - возвращает текущее время в системе и сохраняет его в переменную-параметр. Знать время нам не нужно, поэтому передаем в `time` параметром `nullptr`, чтобы нигде не сохранять результат.


 ```c++       
        srand(time(nullptr)); 

```

Создадим переменную типа данных `Human`:


```c++  
        Human jack; // Знакомьтесь - Джек
        Human alex; // Знакомьтесь - Алекс

 ```   
 
 Джек и Алекс только что родились - мы создали объекты. Теперь им нужно сходить в паспортный стол и получить паспорт.

```c++
        jack.setPassport(170, 80, "Jack Smith");
        alex.setPassport(170, 80, "Alex Ranger");

        cout << "Jack's passport: " << jack.getPassportNumber() << endl;
        cout << "Alex's passport: " << alex.getPassportNumber() << endl;

```

 `Human` - это класс. Он описывает, что есть у каждого человека: характеристики и действия.
 
 `jack` и `alex` - объекты, конкретные представители класса `Human`.
 
 
 
 # Инкапсуляция

Зачем нужны публичные и приватные поля? (Кстати, есть еще модификатор `protected`, но о нем немного позже)

Считается, что вне класса находится жестокий и злой мир, а класс - маленький и беззащитный. Чтобы защитить свой нежный внутренний мир, класс прячет от внешнего мира все свои "потроха", чтобы кто-то случайно или намеренно не сломал информацию внутри класса.
Такой механизм называется **ИНКАПСУЛЯЦИЕЙ**

> **Инкапсуляция** - сокрытие сложности и внутренней структуры класса.

Если серьезно, то класс представляется в виде "черного ящика": *какой алгоритм скрыт в нем, как класс работает, какие поля в нем есть - 
 недопустимо знать пользователю, а тем более иметь возможость изменять информацию в классе напрямую*. Все это делается из рассчета обспечения безопасности. По принципу инкапсуляции принято все поля делать приватными, а доступ к полям организовывать с помощью методов.
 
```c++ 
#include <iostream>
#include <sstream>
using namespace std;

namespace Encapsulation
{
    class Server
    {
        short ipAddress[4] = { 0, 0, 0, 0 };

    public:
        void setIpAddress(short array[])
        {
            if (ipAddress[0] != 0 || ipAddress[1] != 0 || ipAddress[2] != 0 || ipAddress[3] != 0)
            {
                cout << "Ты кто такой, чтобы менять адрес у сервера?! Гуляй отсюда." << endl;
                return;
            }

            for (int i = 0; i < 4; i++)
                if (array[i] < 0 || array[i] > 255)
                {
                    cout << "IP адрес некорректен!" << endl;
                    return;
                }
            for (int i = 0; i < 4; i++)
                ipAddress[i] = array[i];
        }
	
        char* getIpAddress()
        {
           
            stringstream sout; 
            sout << ipAddress[0] << "." << ipAddress[1] << "." << ipAddress[2] << "." << ipAddress[3] << '\0';

            char* ipString = new char[strlen(sout.str().c_str())];
            strcpy(ipString, sout.str().c_str());

            return ipString;
        }
    };

    void main()
    {
        short ip[4]{ 192, 168, 0, 1 };

        Server s;
        s.setIpAddress(ip);

        cout << s.getIpAddress() << endl;

        
        short ip2[4]{ 192, 168, 0, 100 };
        s.setIpAddress(ip); 

    }
} 
 ```
 
>  Метод, который позволяет задать значение поля, называют **сеттером** (от англ. *setter*).
 ```c++
   
        void setIpAddress(short array[])
        {
            // Если ip адрес уже был присвоен серверу...
            if (ipAddress[0] != 0 || ipAddress[1] != 0 || ipAddress[2] != 0 || ipAddress[3] != 0)
            {
                // то менять его уже нельзя!
                cout << "Ты кто такой, чтобы менять адрес у сервера?! Гуляй отсюда." << endl;

                return;
            }
```

**ВАЖНОЕ ЗАМЕЧАНИЕ!**
Т.к. на данном этапе обучения, обработка исключительных ситуаций (ошибок и т.д.) еще темный лес, то сообщения об ошибках выводятся прямо в консоль, **НО!!!** *Работать с интерфейсом (консолью, например) внутри класса считается очень плохим тоном!*
Но пока... Эх, придется делать так. Иначе мозг у кого-то может взорваться.

Внутри сеттера часто помещают проверки на корректность данных.

```c++       
            for (int i = 0; i < 4; i++)
                // проверяем, чтобы все части ip адреса лежали в диапазоне от 1 до 255
                if (array[i] < 0 || array[i] > 255)
                {
                    cout << "IP адрес некорректен!" << endl;
                    return;
                }

            // Если адрес корректен, то сохраняем его
            for (int i = 0; i < 4; i++)
                ipAddress[i] = array[i];
```
> Метод, который позволяет получить значение поля, называют **геттером** (от англ. *getter*).

Все любят потоки! Поток работы со строкой. Записываем в него данные как в обычный поток.

```c++ 
            stringstream sout;
            sout << ipAddress[0] << "." << ipAddress[1] << "." << ipAddress[2] << "." << ipAddress[3] << '\0';

```

Чтобы извлечь данные из потока: `sout.str()` вернет строку типа данных `string` , если придерживаться правила не использовать, то что сам не можешь написать, то чтобы из `string` получить `char*` вызываем метод `c_str()`

```c++    
	 char* ipString = new char[strlen(sout.str().c_str())];
         strcpy(ipString, sout.str().c_str());

         return ipString;
```

Попробуем изменить ip адрес еще раз

```c++ 
        short ip2[4]{ 192, 168, 0, 100 };
        s.setIpAddress(ip);
```
 А вот фиг вам! Там стоит защита.
 
 **ИТОГ:**
 
1.    Инкапсуляция помогает скрыть сложность класса (пользователя не волнует, как мы храним данные внутри класса)

2.    Инкапсуляция обеспечивает уровень безопасности доступа к данным

3.    Инкапсуляция предоставляет механизм для безопасного изменения данных (проверки на корректность данных и т.д.), вместо того, чтобы писать `s.ipAddress = ...`


# Жизненный цикл объекта, конструктор, деструктор

Принципы ООП старались как можно более приблизить реальную жизнь к программным моделям. Поэтому у объектов есть так называемый "жизненный цикл". Объекты рождаются, живут, выполняют свою роль, а затем умирают. Когда объект "рождается" вызывается специальный метод класса - *конструктор*. Когда объект "умирает" вызывается специальный метод класса - *деструктор*.

```c++
class Human
    {
        int height;
        int weight;

    public:
        Human()
        {
            cout << "Я родился! И ничего о себе не знаю." << endl;
        }

        Human(int h)
        {
            height = h;
            cout << "Я родился! И я знаю свой рост! " << height << " см" << endl;
        }

        Human(int h, int w) : height(h), weight(w) 
        {
            cout << "Я родился! И я знаю свой рост и вес! " << height << " см " << weight << " кг" << endl;
        }

        ~Human()
        {
            cout << "RIP" << endl;
        }
    };

    void main()
    {
         Human* temp;
         { 
            Human h1;
            Human h2(54);
            
            Human* h4 = new Human(50); 
            temp = h4; 
         } 
       
         Human h3(48, 3);
         
         delete temp;      
      
        Human* array1 = new Human[5]; 
        delete[] array1; 

        Human* array2 = new Human[5];
        delete array2; 
      
    }
}
```

> **Конструктор** - метод класса, который имеет такое же имя, как и сам класс. Конструктор НЕ ИМЕЕТ возвращаемого значения, потому что результата работы у конструктора - нет. Он что-то делает и все.
```c++  
     Human()
        {
            cout << "Я родился! И ничего о себе не знаю." << endl;
        }
```
Конструктор можно перегружать (может существовать несколько конструкторов с разными параметрами)

```c++    
    Human(int h)
        {
            height = h;
            cout << "Я родился! И я знаю свой рост! " << height << " см" << endl;
        }
```

Если лениво писать внутри конструктора 
`height = h;`
`weight = w;`
то можно использовать краткую версию инициализатора

```c++ 
        Human(int h, int w) : height(h), weight(w) // <-- вот она, после ":"
        {
            cout << "Я родился! И я знаю свой рост и вес! " << height << " см " << weight << " кг" << endl;
        }
```
> **Деструктор** - метод класса, который имеет такое же имя, как и сам класс с тильдой в начале. Деструктор также НЕ ИМЕЕТ возвращаемого значения
	
```c++	
        ~Human()
        {
            cout << "RIP" << endl;
        }
```
 Когда блок кода завершился, то переменные `h1` и `h2` были уничтожены, а перед тем как их "убили" вызвался деструктор, Но удалятся только статические объекты. Обратите внимание, что надпись RIP на данном этапе появилась только 2 раза.
 
```c++
Human* temp;
         { // <-- начало блока кода
            Human h1;
            Human h2(54);
            
            Human* h4 = new Human(50); // Это динамический объект
            temp = h4; // Сохраним адрес, чтобы не потерять
         } // <-- конец блока кода (все локальные переменные будут удалены)
```
Создаем новый объект. Он будет существовать до конца программы

```c++
    Human h3(48, 3);
```
А вот сейчас мы "убьем" динамический объект

```c++ 
  delete temp; // Сейчас вызовется деструктор
```

**ИТОГ:**
* Конструктор вызывается сразу после создания объекта. 
* Делать конструктор может ВСЕ ЧТО УГОДНО. Но чаще всего его используют для начальной инициализации полей класса.
* Деструктор вызывается непосредственно перед удалением объекта. 
* Делать деструктор может ВСЕ ЧТО УГОДНО. Но чаще всего его используют для высвобождения динамической памяти внутри класса.

 А теперь вернемся к вопросу важности `delete` и `delete[]`.
 Наконец-то мы можем "почуствовать" в чем же важность этой разницы
```c++
        Human* array1 = new Human[5]; // 5 раз вызвался конструктор
        delete[] array1; // 5 раз вызвался деструктор
```
 А теперь сделаем неправильно
 ```c++
        Human* array2 = new Human[5];
        delete array2; // Деструктор вызовется 1 раз, а затем... 
```

А затем в лучшем случае будет ошибка, в худшем - непредвиденное поведение.
 
Почему ошибка это лучший случай? Потому что лучше знать, в каком месте в коде вы накосячили, чем программа проскочит это место, а потом что-то пойдет не так в совершенно неожиданном месте.
 
Итак, почему же деструктор вызовется только один раз?
 
Когда мы выделяем память под объект или массив с помощью `new` и `new[]` соответственно на самом деле компилятору без разницы под массив выделяется память или нет, при выделении память просто вычисляется кол-во байт для резервирования, находится участок подходящего размера, он помечается как занятый, а перед этим участком записываются метаданные - размер занятого участка. Все.
 
Разницы между `new` и `new[]` с точки зрения памяти никакой. Но допустим, у нас массив не простых типов данных, а объектов. И у этих объектов есть кастомный деструктор, который нужно запускать. Если вызвать освобождение памяти с помощью `delete`, то память-то высвободится вся, потому что ее размер записан в метаданных, но `delete` будет считать, что объект-то в памяти всего один и лежит там, где указатель ему сказал, а значит деструктор вызывать нужно только один раз!
        
 Но если деструктор вызвался только у одного объекта, за остальными остался "мусор" в памяти... В общем, предсказать что произойдет дальше в программе нельзя. Взорваться не взорвется, но ничем хорошим тоже вряд ли закончится.
 
 Ошибка же может и не всплыть. Но если всплывет, то программа просто увидит повреждение кучи. Повезло. А может и не повезти.

Если же вызывать освобождение через `delete[]`, то `delete[]` проанализирует, сколько объектов в массиве примерно так:

`SIZE / sizeof(T) `

`SIZE` - это размер всей зарезервированной памяти под массив


`T` - тип данных объекта, который хранится в массиве, в нашем примере это был Human
 
 Узнав, что там лежит больше 1 объекта, `delete[]` уже начинает стучаться к каждому и вызывать деструктор.

Теперь вам понятно, когда перепутать `delet` и `delete[]` может быть опасно для жизни. Всегда используйте правильный вариант команды освобождения памяти.
        


# Конструктор копирования

TODO 
